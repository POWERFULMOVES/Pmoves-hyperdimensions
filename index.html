<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperdimensional Functions</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.17/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.17/theme/dracula.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.17/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.17/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.0.0/math.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="sidebar-wrapper">
        <div id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-header-top">
                    <h2>Function Controls</h2>
                    <button id="toggleSidebar">¬´</button>
                </div>
            </div>

            <div id="controlsBody">
                <div class="section">
                    <div class="section-header" id="visualsHeader">
                        <span class="section-caret" id="visualsCaret">‚ñ∂</span>
                        <span class="section-title">Display</span>
                    </div>
                    <div class="section-body" id="visualsBody" style="display: none;">
                        <div class="control-row">
                            <div class="control-group">
                                <label>
                                    <input type="checkbox" id="autoRotate">
                                    Auto rotate
                                </label>
                            </div>
                        </div>

                        <div class="control-row">
                            <div class="control-group">
                                <label for="showAxes">
                                    <input type="checkbox" id="showAxes">
                                    Show axes
                                </label>
                            </div>
                        </div>

                        <div class="control-row">
                            <div class="control-group">
                                <label>
                                    <input type="checkbox" id="showSurface" checked>
                                    Show surface
                                </label>
                            </div>
                        </div>

                        <div class="control-row">
                            <div class="control-group">
                                <label>
                                    <input type="checkbox" id="showWireframe">
                                    Show wireframe
                                </label>
                            </div>
                        </div>

                        <div class="control-row">
                            <div class="control-group-inline">
                                <label for="dirIntensity">Light intensity</label>
                                <input type="number" id="dirIntensity" min="0" max="3" step="0.1" value="1.0">
                            </div>
                            <div class="control-group-inline">
                                <label for="shininess">Shininess</label>
                                <input type="number" id="shininess" min="0" max="2000" step="10" value="100">
                            </div>
                        </div>
                    </div>
                </div>

                <hr class="section-divider">

                <div class="section" id="parametersSection">
                    <div class="section-header" id="parametersHeader">
                        <span class="section-caret" id="parametersCaret">‚ñº</span>
                        <span class="section-title">Parameters</span>
                    </div>
                    <div class="section-body" id="parametersBody">
                        <div class="control-row">
                            <div class="control-group-inline">
                                <label for="uMin">U min</label>
                                <input type="text" id="uMin" inputmode="decimal" value="0">
                            </div>
                            <div class="control-group-inline">
                                <label for="uMax">max</label>
                                <input type="text" id="uMax" inputmode="decimal" value="1">
                            </div>
                            <div class="control-group-inline">
                                <label for="uSegs">resolution</label>
                                <input type="number" id="uSegs" min="10" max="500" value="150">
                            </div>
                        </div>

                        <div class="control-row">
                            <div class="control-group-inline">
                                <label for="vMin">V min</label>
                                <input type="text" id="vMin" inputmode="decimal" value="0">
                            </div>
                            <div class="control-group-inline">
                                <label for="vMax">max</label>
                                <input type="text" id="vMax" inputmode="decimal" value="1">
                            </div>
                            <div class="control-group-inline">
                                <label for="vSegs">resolution</label>
                                <input type="number" id="vSegs" min="3" max="500" value="150">
                            </div>
                        </div>

                        <div id="paramExtras"></div>
                        <div class="control-row" id="globalParamControls" style="display: none;">
                            <div class="control-group-inline">
                                <button id="playAllParams">‚ñ∂ Play All</button>
                            </div>
                            <div class="control-group-inline">
                                <button id="pauseAllParams">‚è∏ Pause All</button>
                            </div>
                            <div class="control-group-inline">
                                <button id="randomizeParams">üé≤ Randomize</button>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-group">
                                <button id="addParam">Add Parameter</button>
                            </div>
                        </div>
                    </div>
                </div>

                <hr class="section-divider">

                <div class="section">
                    <div class="section-header" id="surfaceHeader">
                        <span class="section-caret" id="surfaceCaret">‚ñº</span>
                        <span class="section-title">Surface function</span>
                    </div>
                    <div class="section-body" id="surfaceBody">
                        <div class="control-row">
                            <div class="control-group">
                                <textarea id="surfaceEditor" spellcheck="false"></textarea>
                            </div>
                        </div>
                        <div id="surfaceError" class="surface-error" style="display: none;"></div>
                    </div>
                </div>

                <hr class="section-divider">

                <div class="section">
                    <div class="section-header" id="outputsHeader">
                        <span class="section-caret" id="outputsCaret">‚ñ∂</span>
                        <span class="section-title">Outputs</span>
                    </div>
                    <div class="section-body" id="outputsBody" style="display: none;">
                        <div class="control-row">
                            <div class="control-group-inline outputs-row">
                                <label for="coordConversion">Convert XYZ coordinates to</label>
                                <select id="coordConversion">
                                    <option value="none">None</option>
                                    <option value="spherical">Spherical (r, Œ∏, œÜ)</option>
                                    <option value="cylindrical">Cylindrical (œÅ, œÜ, z)</option>
                                </select>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-group-inline outputs-row">
                                <label for="rgbToHsv">Convert RGB to HSV</label>
                                <input type="checkbox" id="rgbToHsv">
                            </div>
                        </div>
                        <div class="outputs-note">
                            (conversions occur after function code is executed, they do not require any code changes)
                        </div>
                    </div>
                </div>
            </div>

            <div id="sidebar-footer">
                <div class="footer-buttons-grid">
                    <button id="applySurface" disabled>Apply</button>
                    <button id="revertSurface" disabled>Revert</button>
                    <button id="saveConfig">Save</button>
                    <button id="loadConfig">Load</button>
                    <button id="cancelPanels" class="footer-cancel" style="display: none; grid-column: 1 / -1;">Cancel</button>
                </div>
                <div class="sidebar-footer-panel" id="sidebarHeaderPanel" style="display: none;">
                    <div id="savePanel" class="header-panel" style="display: none;">
                        <div class="header-panel-row">
                            <label for="saveName">Save As:</label>
                            <input type="text" id="saveName" placeholder="Name">
                            <button id="downloadSave">Download</button>
                        </div>
                    </div>
                    <div id="loadPanel" class="header-panel" style="display: none;">
                        <div class="header-panel-row header-panel-row-load">
                            <label for="loadPreset">Choose Saved:</label>
                            <select id="loadPreset">
                                <option value="shell">shell</option>
                            </select>
                            <button id="loadPresetBtn">Load</button>
                            <span class="header-panel-or-inline">~or~</span>
                            <button id="uploadSaveBtn">Upload Custom</button>
                            <input type="file" id="uploadSaveInput" style="display: none;">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="sidebar-resizer"></div>
    </div>

    <div id="viewport">
        <button id="resetCamera" class="floating-button" title="Reset camera">‚Üª</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';

        // --- Parameters ---
        const params = {
            uMin: 0,
            uMax: 1,
            vMin: 0,
            vMax: 1,
            uSegs: 150,
            vSegs: 150
        };

        // --- The Parametric Functions ---
        
        // Combined function that returns everything
        // x, y, z: position
        // r, g, b: color [0,1]
        // a: alpha [0,1] (optional, defaults to 1)

        // Default placeholder surface
function surface(input) {
    return { x: 0, y: 0, z: 0, r: 1, g: 1, b: 1, a: 1 };
}

        let surfaceFn = surface;
        let currentLoadedFile = 'nautilus.json'; // Track currently loaded file
        const surfaceInput = { u: 0, v: 0 };
        const animatedParams = [];
        let coordConversionMode = 'none'; // 'none' | 'spherical' | 'cylindrical'
        let convertRgbToHsv = false;

        function normalizeSurfaceOutput(raw) {
            const clamp01 = (v) => {
                if (typeof v !== 'number' || !Number.isFinite(v)) return 1;
                if (v < 0) return 0;
                if (v > 1) return 1;
                return v;
            };
            const safePos = (v) => (typeof v === 'number' && Number.isFinite(v) ? v : 0);

            const data = raw || {};
            const x = safePos(data.x);
            const y = safePos(data.y);
            const z = safePos(data.z);

            const r = clamp01(data.r);
            const g = clamp01(data.g);
            const b = clamp01(data.b);
            const a = clamp01(data.a != null ? data.a : 1);

            return { x, y, z, r, g, b, a };
        }

        function applyOutputConversions(raw) {
            if (!raw || typeof raw !== 'object') return raw;

            let { x, y, z, r, g, b, a } = raw;

            // Coordinate conversions interpret x,y,z as the chosen system
            if (coordConversionMode === 'spherical') {
                const radius = typeof x === 'number' ? x : 0;
                const theta = typeof y === 'number' ? y : 0;
                const phi = typeof z === 'number' ? z : 0;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                const sinPhi = Math.sin(phi);
                const cosPhi = Math.cos(phi);
                x = radius * sinTheta * cosPhi;
                y = radius * sinTheta * sinPhi;
                z = radius * cosTheta;
            } else if (coordConversionMode === 'cylindrical') {
                const rho = typeof x === 'number' ? x : 0;
                const phi = typeof y === 'number' ? y : 0;
                const zVal = typeof z === 'number' ? z : 0;
                const cosPhi = Math.cos(phi);
                const sinPhi = Math.sin(phi);
                x = rho * cosPhi;
                y = rho * sinPhi;
                z = zVal;
            }

            if (convertRgbToHsv) {
                const rr = typeof r === 'number' ? r : 0;
                const gg = typeof g === 'number' ? g : 0;
                const bb = typeof b === 'number' ? b : 0;

                const max = Math.max(rr, gg, bb);
                const min = Math.min(rr, gg, bb);
                const d = max - min;
                let h = 0;
                const v = max;
                const s = max === 0 ? 0 : d / max;

                if (d !== 0) {
                    if (max === rr) {
                        h = (gg - bb) / d + (gg < bb ? 6 : 0);
                    } else if (max === gg) {
                        h = (bb - rr) / d + 2;
                    } else {
                        h = (rr - gg) / d + 4;
                    }
                    h /= 6;
                }

                r = h;
                g = s;
                b = v;
            }

            return { x, y, z, r, g, b, a };
        }

        function formatScalar(value) {
            if (typeof value !== 'number' || !Number.isFinite(value)) return '';
            return Number(value).toFixed(5).replace(/\.?0+$/, '');
        }

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(35, 25, 35);
        camera.up.set(0, 0, 1); // Z-up orientation
        const initialCameraPosition = camera.position.clone();
        const initialTarget = new THREE.Vector3(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        const viewport = document.getElementById('viewport');
        viewport.appendChild(renderer.domElement);

        function resizeRendererToViewport() {
            const rect = viewport.getBoundingClientRect();
            const width = rect.width || window.innerWidth;
            const height = rect.height || window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }

        resizeRendererToViewport();

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxDistance = 4000;
        controls.target.copy(initialTarget);
        controls.autoRotateSpeed = 5;

        // --- Geometry Generation ---
        
        let mesh;
        let wireframe;
        let geometry;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        let lastUSegs = -1;
        let lastVSegs = -1;
        
        // This function is passed to ParametricGeometry constructor.
        // It sets initial positions. We don't rely on it for colors or updates.
        function meshFunction(u, v, target) {
            const u_norm = params.uMin + u * (params.uMax - params.uMin);
            const v_norm = params.vMin + v * (params.vMax - params.vMin);
            surfaceInput.u = u_norm;
            surfaceInput.v = v_norm;
            // We only need position here
            const converted = applyOutputConversions(surfaceFn(surfaceInput));
            const out = normalizeSurfaceOutput(converted);
            target.set(out.x, out.y, out.z);
        }

        function getCurrentShininess() {
            const input = document.getElementById('shininess');
            if (!input) return 100;
            const v = parseFloat(input.value);
            return Number.isNaN(v) ? 100 : v;
        }

        function updateSurfaceExtraParams() {
            // Clear existing extra keys (keep u, v)
            Object.keys(surfaceInput).forEach((key) => {
                if (key !== 'u' && key !== 'v') {
                    delete surfaceInput[key];
                }
            });

            const container = document.getElementById('paramExtras');
            if (!container) return;
            const rows = container.querySelectorAll('.param-row');
            const identifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;

            rows.forEach((row) => {
                const nameInput = row.querySelector('.param-name');
                const valueInput = row.querySelector('.param-value');
                if (!nameInput || !valueInput) return;

                const name = nameInput.value.trim();
                if (!identifier.test(name)) return;

                const val = parseFloat(valueInput.value);
                if (Number.isNaN(val)) return;

                surfaceInput[name] = val;
            });
        }

        function updateGeometry() {
            updateSurfaceExtraParams();
            
            const uSegs = params.uSegs;
            const vSegs = params.vSegs;
            const needRebuild = !geometry || uSegs !== lastUSegs || vSegs !== lastVSegs;

            if (needRebuild) {
                if (mesh) scene.remove(mesh);
                if (wireframe) {
                    scene.remove(wireframe);
                    wireframe.geometry.dispose();
                    wireframe.material.dispose();
                    wireframe = null;
                }
                if (geometry) geometry.dispose();

                // Create new geometry
                geometry = new ParametricGeometry(meshFunction, uSegs, vSegs);
                lastUSegs = uSegs;
                lastVSegs = vSegs;

                // Create color attribute (RGBA)
                const count = geometry.attributes.position.count;
                geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count * 4), 4));

                // Create Material
                const material = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    shininess: getCurrentShininess(),
                    transparent: true,
                    opacity: 1.0,
                    side: THREE.DoubleSide
                });

                mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);

                const wireMat = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.2
                });
                wireframe = new THREE.LineSegments(geometry, wireMat);
                scene.add(wireframe);

                const surfaceToggle = document.getElementById('showSurface');
                const wireToggle = document.getElementById('showWireframe');
                mesh.visible = surfaceToggle ? surfaceToggle.checked : true;
                wireframe.visible = wireToggle ? wireToggle.checked : false;
            }

            // Update Loop (Runs every time, whether rebuilt or not)
            const positions = geometry.attributes.position;
            const colors = geometry.attributes.color;
            const uMin = params.uMin;
            const uMax = params.uMax;
            const vMin = params.vMin;
            const vMax = params.vMax;
            
            let idx = 0;
            // ParametricGeometry iterates stacks (v) then slices (u)
            for (let i = 0; i <= vSegs; i++) {
                const v = i / vSegs;
                const v_norm = vMin + v * (vMax - vMin);
                
                for (let j = 0; j <= uSegs; j++) {
                    const u = j / uSegs;
                    const u_norm = uMin + u * (uMax - uMin);

                    surfaceInput.u = u_norm;
                    surfaceInput.v = v_norm;

                    const converted = applyOutputConversions(surfaceFn(surfaceInput));
                    const out = normalizeSurfaceOutput(converted);

                    positions.setXYZ(idx, out.x, out.y, out.z);
                    colors.setXYZW(idx, out.r, out.g, out.b, out.a);
                    
                    idx++;
                }
            }

            positions.needsUpdate = true;
            colors.needsUpdate = true;
            geometry.computeVertexNormals();
        }

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(20, 30, 10);
        scene.add(dirLight);
        
        const pointLight = new THREE.PointLight(0xffaa00, 0.5);
        pointLight.position.set(-15, -10, 10);
        scene.add(pointLight);

        const spotLight = new THREE.SpotLight(0xffddaa, 0.6, 120, Math.PI / 6, 0.4);
        spotLight.position.set(0, 40, 20);
        spotLight.target.position.set(0, 0, 0);
        scene.add(spotLight);
        scene.add(spotLight.target);

        const axes = new THREE.AxesHelper(30);
        scene.add(axes);
        axes.visible = false;

        // Click marker for camera target feedback
        const clickMarkerGeo = new THREE.SphereGeometry(0.6, 16, 16);
        const clickMarkerMat = new THREE.MeshBasicMaterial({
            color: 0xffff66,
            transparent: true,
            opacity: 0.0
        });
        const clickMarker = new THREE.Mesh(clickMarkerGeo, clickMarkerMat);
        clickMarker.visible = false;
        scene.add(clickMarker);

        let markerStartTime = 0;
        const markerDuration = 400; // ms

        // Camera tweening state
        let isCameraTweening = false;
        let camTweenStart = 0;
        const camTweenDuration = 600; // ms
        const camStartPos = new THREE.Vector3();
        const camStartTarget = new THREE.Vector3();
        const camEndPos = new THREE.Vector3();
        const camEndTarget = new THREE.Vector3();

        // Keyboard state for WASD camera panning
        const keyState = { w: false, a: false, s: false, d: false, " ": false, x: false, shift: false };
        window.addEventListener('keydown', (e) => {
            if (e.target.matches('input, textarea, select')) return;
            const key = e.key.toLowerCase();
            if (keyState.hasOwnProperty(key)) {
                keyState[key] = true;
                e.preventDefault();
            }
        });
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keyState.hasOwnProperty(key)) {
                keyState[key] = false;
                e.preventDefault();
            }
        });

        // Geometry update scheduling
        let geometryNeedsUpdate = false;
        function scheduleGeometryUpdate() {
            if (geometryNeedsUpdate) return;
            geometryNeedsUpdate = true;
            requestAnimationFrame(() => {
                geometryNeedsUpdate = false;
                updateGeometry();
            });
        }

        let lastFrameTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            
            const now = performance.now();
            const dt = (now - lastFrameTime) / 1000;
            lastFrameTime = now;

            // Handle WASD camera panning
            if (keyState.w || keyState.a || keyState.s || keyState.d || keyState[" "] || keyState.x) {
                // Determine speed based on distance to target
                const dist = controls.getDistance();
                let speed = dist * 0.5 * dt;

                if (keyState.shift) {
                    speed *= 5;
                }

                // We want to move relative to camera view
                // 1. Get camera forward vector (3D)
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.normalize();

                // 2. Get camera right vector (local X) projected on XY to keep strafing level
                // (Optional: remove .z=0 if you want 3D strafing when rolled, but usually horizontal strafe is preferred)
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                right.z = 0;
                right.normalize();

                const move = new THREE.Vector3();
                if (keyState.w) move.add(forward);
                if (keyState.s) move.sub(forward);
                if (keyState.d) move.add(right);
                if (keyState.a) move.sub(right);
                
                // Up/Down movement (Global Z)
                if (keyState[" "]) move.add(new THREE.Vector3(0, 0, 1));
                if (keyState.x) move.sub(new THREE.Vector3(0, 0, 1));

                if (move.lengthSq() > 0) {
                    move.normalize().multiplyScalar(speed);
                    camera.position.add(move);
                    controls.target.add(move);
                }
            }

            // Animate camera tween
            if (isCameraTweening) {
                const tRaw = (now - camTweenStart) / camTweenDuration;
                const t = tRaw >= 1 ? 1 : tRaw;
                const smoothT = t * t * (3 - 2 * t); // smoothstep easing

                camera.position.lerpVectors(camStartPos, camEndPos, smoothT);
                controls.target.lerpVectors(camStartTarget, camEndTarget, smoothT);

                if (t >= 1) {
                    isCameraTweening = false;
                }
            }

            // Animate click marker
            if (clickMarker.visible) {
                // Scale based on distance to camera to keep roughly constant screen size
                const dist = camera.position.distanceTo(clickMarker.position);
                const baseScale = dist * 0.015;

                const mRaw = (now - markerStartTime) / markerDuration;
                if (mRaw >= 1) {
                    clickMarker.visible = false;
                } else {
                    const inv = 1 - mRaw;
                    clickMarkerMat.opacity = inv;
                    // Pulse animation on top of distance scaling
                    const pulse = 1 + 0.5 * mRaw;
                    const scale = baseScale * pulse;
                    clickMarker.scale.set(scale, scale, scale);
                }
            }

            // Animate parameter playback
            let anyParamChanged = false;
            if (animatedParams.length > 0) {
                animatedParams.forEach((state) => {
                    if (!state.playing) {
                        state.lastTime = now;
                        return;
                    }
                    const runtime = parseFloat(state.timeInput.value);
                    const step = parseFloat(state.stepInput.value);
                    let minVal = parseFloat(state.minInput.value);
                    let maxVal = parseFloat(state.maxInput.value);
                    if (!Number.isFinite(runtime) || runtime <= 0) {
                        state.lastTime = now;
                        return;
                    }
                    if (!Number.isFinite(minVal) || !Number.isFinite(maxVal) || maxVal <= minVal) {
                        state.lastTime = now;
                        return;
                    }
                    const dtMs = now - state.lastTime;
                    if (dtMs <= 0) return;
                    state.lastTime = now;
                    const dt = dtMs / 1000;
                    const loopDuration = runtime; // seconds for min->max->min
                    const range = maxVal - minVal;
                    if (range <= 0) return;

                    let phase = state.phase + dt / loopDuration;
                    phase = phase - Math.floor(phase); // wrap 0..1
                    state.phase = phase;

                    let value;
                    if (phase <= 0.5) {
                        value = minVal + (phase * 2) * range;
                    } else {
                        value = maxVal - ((phase * 2 - 1) * range);
                    }

                    const s = Number.isFinite(step) && step > 0 ? step : (range / 100);
                    let snapped = minVal + Math.round((value - minVal) / s) * s;
                    if (snapped < minVal) snapped = minVal;
                    if (snapped > maxVal) snapped = maxVal;

                    state.valueInput.value = formatScalar(snapped);
                    state.sliderInput.value = String(snapped);
                    anyParamChanged = true;
                });
            }

            if (anyParamChanged) {
                scheduleGeometryUpdate();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', resizeRendererToViewport);
        
        // --- UI Logic ---
        function setupUI() {
            const ids = ['uMin', 'uMax', 'vMin', 'vMax'];
            
            function evaluateMathExpression(raw) {
                const expr = String(raw || '').trim();
                if (!expr.length) return null;
                if (!window.math || typeof window.math.evaluate !== 'function') return null;
                const out = window.math.evaluate(expr);
                const num = typeof out === 'number' ? out : Number(out);
                return Number.isFinite(num) ? num : null;
            }

            function applyUvBoundFromInput(id) {
                const el = document.getElementById(id);
                if (!el) return;

                const raw = String(el.value || '').trim();
                const evaluated = evaluateMathExpression(raw);

                const isMin = id === 'uMin' || id === 'vMin';
                const axis = id[0]; // 'u' | 'v'
                const otherId = axis + (isMin ? 'Max' : 'Min');
                const otherEl = document.getElementById(otherId);
                const otherVal = otherEl ? evaluateMathExpression(otherEl.value) : null;

                let value;
                if (evaluated == null) {
                    if (otherVal != null) {
                        value = isMin ? (otherVal - 1) : (otherVal + 1);
                    } else {
                        value = isMin ? 0 : 1;
                    }
                } else {
                    value = evaluated;
                }

                params[id] = value;
                el.value = formatScalar(value);
                scheduleGeometryUpdate();
            }

            ids.forEach((id) => {
                const el = document.getElementById(id);
                if (!el) return;

                el.addEventListener('blur', () => applyUvBoundFromInput(id));
                el.addEventListener('change', () => applyUvBoundFromInput(id));
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        applyUvBoundFromInput(id);
                        el.blur();
                    }
                });
            });

            const axesCheckbox = document.getElementById('showAxes');
            axesCheckbox.addEventListener('change', (e) => {
                axes.visible = e.target.checked;
            });

            const surfaceToggle = document.getElementById('showSurface');
            const wireToggle = document.getElementById('showWireframe');
            const dirIntensity = document.getElementById('dirIntensity');
            const shininessInput = document.getElementById('shininess');
            const autoRotateCheckbox = document.getElementById('autoRotate');
            const addParamBtn = document.getElementById('addParam');
            const globalParamControls = document.getElementById('globalParamControls');
            const playAllBtn = document.getElementById('playAllParams');
            const pauseAllBtn = document.getElementById('pauseAllParams');
            const randomizeBtn = document.getElementById('randomizeParams');

            function updateGlobalControlsVisibility() {
                if (globalParamControls) {
                    globalParamControls.style.display = animatedParams.length > 1 ? '' : 'none';
                }
            }

            playAllBtn.addEventListener('click', () => {
                const now = performance.now();
                animatedParams.forEach(state => {
                    if (!state.playing) {
                        // Calculate phase from current value so it doesn't jump
                        let minVal = parseNum(state.minInput, -1);
                        let maxVal = parseNum(state.maxInput, 1);
                        let current = parseNum(state.valueInput, minVal);

                        if (maxVal <= minVal) maxVal = minVal + 1;
                        const range = maxVal - minVal;

                        current = Math.min(Math.max(current, minVal), maxVal);
                        const tUp = (current - minVal) / range;
                        const clampedUp = Math.min(Math.max(tUp, 0), 1);
                        
                        // Triangle wave: 0..0.5 is rising edge
                        state.phase = 0.5 * clampedUp;

                        state.playing = true;
                        state.playButton.textContent = '‚è∏';
                        state.lastTime = now;
                    }
                });
                scheduleGeometryUpdate();
            });

            pauseAllBtn.addEventListener('click', () => {
                animatedParams.forEach(state => {
                    if (state.playing) {
                        state.playing = false;
                        state.playButton.textContent = '‚ñ∂';
                        state.lastTime = performance.now(); // Not strictly needed for pause, but good hygiene
                    }
                });
                scheduleGeometryUpdate();
            });

            randomizeBtn.addEventListener('click', () => {
                const now = performance.now();
                animatedParams.forEach(state => {
                    let minVal = parseNum(state.minInput, -1);
                    let maxVal = parseNum(state.maxInput, 1);
                    const step = parseNum(state.stepInput, 0.001);

                    if (maxVal <= minVal) {
                        maxVal = minVal + 1;
                    }
                    const range = maxVal - minVal;
                    
                    // Generate random value within range
                    let rawVal = minVal + Math.random() * range;

                    // Snap to step
                    if (step > 0) {
                        const steps = Math.round((rawVal - minVal) / step);
                        rawVal = minVal + steps * step;
                    }

                    // Clamp
                    rawVal = Math.min(Math.max(rawVal, minVal), maxVal);

                    // Update UI
                    state.valueInput.value = formatScalar(rawVal);
                    state.sliderInput.value = String(rawVal);

                    // Update phase so animation continues smoothly from this new value (on rising edge)
                    if (range > 0) {
                        const tUp = (rawVal - minVal) / range;
                        const clampedUp = Math.min(Math.max(tUp, 0), 1);
                        state.phase = 0.5 * clampedUp;
                    }
                    state.lastTime = now;
                });
                scheduleGeometryUpdate();
            });

            surfaceToggle.addEventListener('change', (e) => {
                if (mesh) mesh.visible = e.target.checked;
            });

            wireToggle.addEventListener('change', (e) => {
                if (wireframe) wireframe.visible = e.target.checked;
            });

            dirIntensity.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                if (!Number.isNaN(v)) {
                    dirLight.intensity = v;
                }
            });

            shininessInput.addEventListener('input', () => {
                if (!mesh || !Array.isArray(mesh.material) && !mesh.material) return;
                const value = getCurrentShininess();
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => { if (m && 'shininess' in m) m.shininess = value; });
                } else if ('shininess' in mesh.material) {
                    mesh.material.shininess = value;
                }
            });
            
            autoRotateCheckbox.addEventListener('change', (e) => {
                controls.autoRotate = e.target.checked;
            });
            
            function attachResolutionHandlers(inputEl, key, minVal, maxVal) {
                function applyResolution() {
                    const raw = inputEl.value;
                    if (!raw.length) return;
                    let value = parseInt(raw, 10);
                    if (Number.isNaN(value)) return;
                    if (value < minVal) value = minVal;
                    if (value > maxVal) value = maxVal;
                    inputEl.value = value;
                    params[key] = value;
                    scheduleGeometryUpdate();
                }

                ['blur', 'change'].forEach(evt => {
                    inputEl.addEventListener(evt, applyResolution);
                });

                inputEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        applyResolution();
                    }
                });
            }

            const uSegsInput = document.getElementById('uSegs');
            const vSegsInput = document.getElementById('vSegs');
            attachResolutionHandlers(uSegsInput, 'uSegs', 10, 500);
            attachResolutionHandlers(vSegsInput, 'vSegs', 3, 500);

            const visualsHeader = document.getElementById('visualsHeader');
            const visualsBody = document.getElementById('visualsBody');
            const visualsCaret = document.getElementById('visualsCaret');

            visualsHeader.addEventListener('click', () => {
                const isHidden = visualsBody.style.display === 'none';
                visualsBody.style.display = isHidden ? '' : 'none';
                visualsCaret.textContent = isHidden ? '‚ñº' : '‚ñ∂';
            });

            const parametersHeader = document.getElementById('parametersHeader');
            const parametersBody = document.getElementById('parametersBody');
            const parametersCaret = document.getElementById('parametersCaret');

            parametersHeader.addEventListener('click', () => {
                const isHidden = parametersBody.style.display === 'none';
                parametersBody.style.display = isHidden ? '' : 'none';
                parametersCaret.textContent = isHidden ? '‚ñº' : '‚ñ∂';
            });

            const outputsHeader = document.getElementById('outputsHeader');
            const outputsBody = document.getElementById('outputsBody');
            const outputsCaret = document.getElementById('outputsCaret');

            outputsHeader.addEventListener('click', () => {
                const isHidden = outputsBody.style.display === 'none';
                outputsBody.style.display = isHidden ? '' : 'none';
                outputsCaret.textContent = isHidden ? '‚ñº' : '‚ñ∂';
            });

            const surfaceHeader = document.getElementById('surfaceHeader');
            const surfaceBody = document.getElementById('surfaceBody');
            const surfaceCaret = document.getElementById('surfaceCaret');

            const coordSelect = document.getElementById('coordConversion');
            const rgbToHsvCheckbox = document.getElementById('rgbToHsv');

            coordSelect.addEventListener('change', () => {
                coordConversionMode = coordSelect.value || 'none';
                scheduleGeometryUpdate();
            });

            rgbToHsvCheckbox.addEventListener('change', () => {
                convertRgbToHsv = rgbToHsvCheckbox.checked;
                scheduleGeometryUpdate();
            });

            const saveBtn = document.getElementById('saveConfig');
            const loadBtn = document.getElementById('loadConfig');
            const cancelPanelsBtn = document.getElementById('cancelPanels');
            const headerPanel = document.getElementById('sidebarHeaderPanel');
            const savePanel = document.getElementById('savePanel');
            const loadPanel = document.getElementById('loadPanel');
            const uploadSaveBtn = document.getElementById('uploadSaveBtn');
            const uploadSaveInput = document.getElementById('uploadSaveInput');
            const loadPresetSelect = document.getElementById('loadPreset');
            const loadPresetBtn = document.getElementById('loadPresetBtn');

            function setFooterCancelVisible(visible) {
                if (!saveBtn || !loadBtn || !cancelPanelsBtn) return;
                saveBtn.style.display = visible ? 'none' : '';
                loadBtn.style.display = visible ? 'none' : '';
                cancelPanelsBtn.style.display = visible ? '' : 'none';
            }

            function hideHeaderPanels() {
                headerPanel.style.display = 'none';
                savePanel.style.display = 'none';
                loadPanel.style.display = 'none';
                setFooterCancelVisible(false);
            }

            saveBtn.addEventListener('click', () => {
                const saveVisible = headerPanel.style.display !== 'none' && savePanel.style.display !== 'none';
                if (saveVisible) {
                    hideHeaderPanels();
                    return;
                }
                headerPanel.style.display = '';
                savePanel.style.display = '';
                loadPanel.style.display = 'none';
                setFooterCancelVisible(true);
            });

            function reloadSaveList() {
                if (!loadPresetSelect) return;
                fetch('saves/_list.json')
                    .then((res) => {
                        if (!res.ok) throw new Error('Failed to load save list');
                        return res.json();
                    })
                    .then((list) => {
                        if (!Array.isArray(list)) return;
                        loadPresetSelect.innerHTML = '';
                        list.forEach((item) => {
                            if (!item || typeof item !== 'object') return;
                            const name = item.name || item.file || 'unnamed';
                            const file = item.file || '';
                            if (!file) return;
                            const opt = document.createElement('option');
                            opt.value = file;
                            opt.textContent = name;
                            if (file === currentLoadedFile) {
                                opt.selected = true;
                            }
                            loadPresetSelect.appendChild(opt);
                        });
                        if (!loadPresetSelect.options.length) {
                            const opt = document.createElement('option');
                            opt.value = '';
                            opt.textContent = 'No saves found';
                            loadPresetSelect.appendChild(opt);
                        }
                    })
                    .catch((err) => {
                        console.error(err);
                    });
            }

            loadBtn.addEventListener('click', () => {
                const loadVisible = headerPanel.style.display !== 'none' && loadPanel.style.display !== 'none';
                if (loadVisible) {
                    hideHeaderPanels();
                    return;
                }
                headerPanel.style.display = '';
                loadPanel.style.display = '';
                savePanel.style.display = 'none';
                setFooterCancelVisible(true);
                reloadSaveList();
            });

            if (cancelPanelsBtn) {
                cancelPanelsBtn.addEventListener('click', () => {
                    hideHeaderPanels();
                });
            }

            uploadSaveBtn.addEventListener('click', () => {
                if (uploadSaveInput) {
                    uploadSaveInput.click();
                }
            });

            reloadSaveList();

            if (loadPresetBtn && loadPresetSelect) {
                loadPresetBtn.addEventListener('click', () => {
                    const file = loadPresetSelect.value;
                    if (!file) return;
                    fetch('saves/' + file)
                        .then((res) => {
                            if (!res.ok) throw new Error('Failed to load preset');
                            return res.json();
                        })
                        .then((cfg) => {
                            currentLoadedFile = file;
                            applyConfig(cfg);
                            hideHeaderPanels();
                        })
                        .catch((err) => {
                            console.error(err);
                            alert('Failed to load preset save file.');
                        });
                });
            }

            // Helper to parse numbers from inputs
            function parseNum(el, fallback) {
                const raw = el.value;
                if (!raw.length) return fallback;
                const v = parseFloat(raw);
                return Number.isNaN(v) ? fallback : v;
            }

            function addParameterRow() {
                const container = document.getElementById('paramExtras');
                if (!container) return;

                const section = document.createElement('div');
                section.className = 'section param-section';

                const body = document.createElement('div');
                body.className = 'section-body';

                const row = document.createElement('div');
                row.className = 'control-row param-row';

                const nameGroup = document.createElement('div');
                nameGroup.className = 'control-group-inline';
                const nameLabel = document.createElement('label');
                nameLabel.textContent = 'name';
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'param-name';
                nameGroup.appendChild(nameLabel);
                nameGroup.appendChild(nameInput);

                const eqSpan = document.createElement('span');
                eqSpan.textContent = '=';
                eqSpan.style.alignSelf = 'flex-end';
                eqSpan.style.color = '#aaa';

                const valueGroup = document.createElement('div');
                valueGroup.className = 'control-group-inline';
                const valueLabel = document.createElement('label');
                valueLabel.textContent = 'value';
                const valueInput = document.createElement('input');
                valueInput.type = 'number';
                valueInput.step = '0.01';
                valueInput.className = 'param-value';
                valueInput.value = '1';
                valueGroup.appendChild(valueLabel);
                valueGroup.appendChild(valueInput);

                row.appendChild(nameGroup);
                row.appendChild(eqSpan);
                row.appendChild(valueGroup);

                const sliderRow = document.createElement('div');
                sliderRow.className = 'control-row';

                const minGroup = document.createElement('div');
                minGroup.className = 'control-group-inline';
                const minLabel = document.createElement('label');
                minLabel.textContent = 'min';
                const minInput = document.createElement('input');
                minInput.type = 'number';
                minInput.step = '0.01';
                minInput.className = 'param-min';
                minGroup.appendChild(minLabel);
                minGroup.appendChild(minInput);

                const sliderGroup = document.createElement('div');
                sliderGroup.className = 'control-group-inline param-slider-group';
                const sliderLabel = document.createElement('label');
                sliderLabel.textContent = '';
                const sliderInput = document.createElement('input');
                sliderInput.type = 'range';
                sliderInput.className = 'param-slider';
                sliderGroup.appendChild(sliderLabel);
                sliderGroup.appendChild(sliderInput);

                const maxGroup = document.createElement('div');
                maxGroup.className = 'control-group-inline';
                const maxLabel = document.createElement('label');
                maxLabel.textContent = 'max';
                const maxInput = document.createElement('input');
                maxInput.type = 'number';
                maxInput.step = '0.01';
                maxInput.className = 'param-max';
                maxGroup.appendChild(maxLabel);
                maxGroup.appendChild(maxInput);

                sliderRow.appendChild(minGroup);
                sliderRow.appendChild(sliderGroup);

                const stepGroup = document.createElement('div');
                stepGroup.className = 'control-group-inline param-step-group';
                const stepLabel = document.createElement('label');
                stepLabel.textContent = 'step';
                const stepInput = document.createElement('input');
                stepInput.type = 'number';
                stepInput.step = '0.001';
                stepInput.className = 'param-step';
                stepInput.value = '0.001';
                stepGroup.appendChild(stepLabel);
                stepGroup.appendChild(stepInput);

                const playGroup = document.createElement('div');
                playGroup.className = 'control-group param-play-group';
                const playButton = document.createElement('button');
                playButton.type = 'button';
                playButton.textContent = '‚ñ∂';
                playGroup.appendChild(playButton);

                sliderRow.appendChild(maxGroup);
                sliderRow.appendChild(stepGroup);

                const playRow = document.createElement('div');
                playRow.className = 'control-row';
                const timeGroup = document.createElement('div');
                timeGroup.className = 'control-group-inline param-time-group';
                const timeLabel = document.createElement('label');
                timeLabel.textContent = 'runtime (s)';
                const timeInput = document.createElement('input');
                timeInput.type = 'number';
                timeInput.step = '0.1';
                timeInput.className = 'param-time';
                timeInput.value = '8';
                timeGroup.appendChild(timeLabel);
                timeGroup.appendChild(timeInput);

                playRow.appendChild(playGroup);
                playRow.appendChild(timeGroup);

                body.appendChild(row);
                body.appendChild(sliderRow);
                body.appendChild(playRow);
                section.appendChild(body);

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'param-remove';
                removeBtn.textContent = '‚úï';
                section.appendChild(removeBtn);

                container.appendChild(section);

                // Compute default unique name: t, t1, t2, ...
                const existingNames = new Set(['u', 'v']);
                Object.keys(params).forEach(k => existingNames.add(k));
                container.querySelectorAll('.param-name').forEach(input => {
                    const n = input.value.trim();
                    if (n) existingNames.add(n);
                });
                let base = 't';
                let candidate = base;
                let idx = 1;
                while (existingNames.has(candidate)) {
                    candidate = base + idx;
                    idx++;
                }
                nameInput.value = candidate;
                nameInput.dataset.prevName = candidate;

                function validateAndApplyName() {
                    const raw = nameInput.value.trim();
                    if (!raw) {
                        nameInput.value = nameInput.dataset.prevName || '';
                        return;
                    }
                    // Ensure valid identifier and uniqueness via quick eval
                    try {
                        new Function(`let ${raw};`);
                    } catch {
                        alert('Parameter name must be a valid JS identifier.');
                        nameInput.value = nameInput.dataset.prevName || '';
                        return;
                    }
                    const allNames = [];
                    container.querySelectorAll('.param-name').forEach(input => {
                        if (input === nameInput) return;
                        const n = input.value.trim();
                        if (n) allNames.push(n);
                    });
                    const reserved = new Set(['u', 'v']);
                    Object.keys(params).forEach(k => reserved.add(k));
                    if (reserved.has(raw) || allNames.includes(raw)) {
                        alert('Parameter name must be unique.');
                        nameInput.value = nameInput.dataset.prevName || '';
                        return;
                    }
                    nameInput.dataset.prevName = raw;
                    scheduleGeometryUpdate();
                }

                nameInput.addEventListener('focus', () => {
                    nameInput.dataset.prevName = nameInput.value;
                });
                nameInput.addEventListener('blur', validateAndApplyName);
                nameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        validateAndApplyName();
                        nameInput.blur();
                    }
                });

                function applyValue() {
                    const valRaw = valueInput.value;
                    if (!valRaw.length) return;
                    const num = parseFloat(valRaw);
                    if (Number.isNaN(num)) return;
                    valueInput.value = formatScalar(num);
                    sliderInput.value = String(num);
                    scheduleGeometryUpdate();
                }

                ['blur', 'change'].forEach(evt => {
                    valueInput.addEventListener(evt, applyValue);
                });
                valueInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        applyValue();
                        valueInput.blur();
                    }
                });

                removeBtn.addEventListener('click', () => {
                    const idx = animatedParams.indexOf(state);
                    if (idx !== -1) animatedParams.splice(idx, 1);
                    section.remove();
                    scheduleGeometryUpdate();
                    updateGlobalControlsVisibility();
                });

                // slider/min/max/step wiring
                function applyMinMax(fromInput) {
                    let minVal = parseNum(minInput, -1);
                    let maxVal = parseNum(maxInput, 1);
                    if (fromInput === minInput && minVal >= maxVal) {
                        maxVal = minVal + 1;
                    } else if (fromInput === maxInput && maxVal <= minVal) {
                        minVal = maxVal - 1;
                    }
                    minInput.value = minVal;
                    maxInput.value = maxVal;
                    sliderInput.min = String(minVal);
                    sliderInput.max = String(maxVal);

                    let val = parseNum(valueInput, 0);
                    if (val < minVal) val = minVal;
                    if (val > maxVal) val = maxVal;
                    valueInput.value = formatScalar(val);
                    sliderInput.value = String(val);
                    scheduleGeometryUpdate();
                }

                function applyStep() {
                    const stepVal = parseNum(stepInput, 0.1);
                    sliderInput.step = String(stepVal);
                }

                function applyMin() {
                    applyMinMax(minInput);
                }
                function applyMax() {
                    applyMinMax(maxInput);
                }

                function initSliderDefaults() {
                    const val = parseNum(valueInput, 1);
                    minInput.value = formatScalar(val - 1);
                    maxInput.value = formatScalar(val + 1);
                    sliderInput.min = minInput.value;
                    sliderInput.max = maxInput.value;
                    sliderInput.value = String(val);
                    sliderInput.step = stepInput.value;
                }

                initSliderDefaults();

                ['blur', 'change'].forEach(evt => {
                    minInput.addEventListener(evt, applyMin);
                    maxInput.addEventListener(evt, applyMax);
                    stepInput.addEventListener(evt, applyStep);
                });

                minInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        applyMin();
                        minInput.blur();
                    }
                });
                maxInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        applyMax();
                        maxInput.blur();
                    }
                });
                stepInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        applyStep();
                        stepInput.blur();
                    }
                });

                sliderInput.addEventListener('input', () => {
                    const v = parseNum(sliderInput, 0);
                    valueInput.value = formatScalar(v);
                    scheduleGeometryUpdate();
                });

                const state = {
                    nameInput,
                    valueInput,
                    minInput,
                    maxInput,
                    sliderInput,
                    stepInput,
                    timeInput,
                    playButton,
                    phase: 0,
                    playing: false,
                    lastTime: performance.now()
                };
                animatedParams.push(state);
                updateGlobalControlsVisibility();

                playButton.addEventListener('click', () => {
                    state.playing = !state.playing;

                    if (state.playing) {
                        const runtime = parseFloat(state.timeInput.value);
                        let minVal = parseNum(minInput, -1);
                        let maxVal = parseNum(maxInput, 1);
                        let current = parseNum(valueInput, minVal);
                        if (maxVal <= minVal) {
                            maxVal = minVal + 1;
                        }
                        const range = maxVal - minVal;
                        current = Math.min(Math.max(current, minVal), maxVal);
                        const tUp = (current - minVal) / range; // 0..1
                        const clampedUp = Math.min(Math.max(tUp, 0), 1);
                        state.phase = 0.5 * clampedUp;
                        state.lastTime = performance.now();
                    }

                    playButton.textContent = state.playing ? '‚è∏' : '‚ñ∂';
                });
            }

            addParamBtn.addEventListener('click', addParameterRow);
            // add a default parameter (t) on load
            addParameterRow();

            const surfaceTextArea = document.getElementById('surfaceEditor');
            const applySurfaceBtn = document.getElementById('applySurface');
            const revertSurfaceBtn = document.getElementById('revertSurface');
            const surfaceErrorEl = document.getElementById('surfaceError');

            const editor = CodeMirror.fromTextArea(surfaceTextArea, {
                mode: 'javascript',
                theme: 'dracula',
                lineNumbers: true,
                tabSize: 2,
                indentUnit: 4,
                lineWrapping: false,
                viewportMargin: Infinity
            });
            editor.setSize(null, 'auto');

            let lastAppliedCode = surface.toString();
            editor.setValue(lastAppliedCode);

            function setSurfaceError(message) {
                if (!surfaceErrorEl) return;
                if (message) {
                    surfaceErrorEl.textContent = message;
                    surfaceErrorEl.style.display = '';
                } else {
                    surfaceErrorEl.textContent = '';
                    surfaceErrorEl.style.display = 'none';
                }
            }

            function updateSurfaceButtonsState() {
                const current = editor.getValue();
                const dirty = current !== lastAppliedCode;
                applySurfaceBtn.disabled = !dirty;
                revertSurfaceBtn.disabled = !dirty;
            }

            function applySurface() {
                const code = editor.getValue();
                try {
                    const factory = new Function(code + '; return surface;');
                    const fn = factory();
                    if (typeof fn !== 'function') {
                        throw new Error('surface is not a function');
                    }

                    try {
                        const testInput = { u: 0.5, v: 0.5 };
                        fn(testInput);
                    } catch (innerErr) {
                        throw new Error(innerErr && innerErr.message ? innerErr.message : 'Error when evaluating surface');
                    }

                    surfaceFn = fn;
                    lastAppliedCode = code;
                    updateGeometry();
                    setSurfaceError('');
                    updateSurfaceButtonsState();
                } catch (err) {
                    console.error(err);
                    setSurfaceError(err && err.message ? err.message : 'Error in surface function');
                }
            }

            applySurfaceBtn.addEventListener('click', applySurface);

            revertSurfaceBtn.addEventListener('click', () => {
                editor.setValue(lastAppliedCode);
                setSurfaceError('');
                updateSurfaceButtonsState();
            });

            editor.addKeyMap({
                'Ctrl-Enter': function(cm) {
                    applySurface();
                }
            });
            editor.on('change', updateSurfaceButtonsState);

            if (surfaceHeader) {
                surfaceHeader.addEventListener('click', () => {
                    const isHidden = surfaceBody.style.display === 'none';
                    surfaceBody.style.display = isHidden ? '' : 'none';
                    surfaceCaret.textContent = isHidden ? '‚ñº' : '‚ñ∂';
                    if (isHidden && editor) {
                        setTimeout(() => editor.refresh(), 10);
                    }
                });
            }

            const saveNameInput = document.getElementById('saveName');
            const downloadSaveBtn = document.getElementById('downloadSave');

            function applyConfig(cfg) {
                if (!cfg || typeof cfg !== 'object') return;

                const toNum = (v, fallback) => (typeof v === 'number' && Number.isFinite(v) ? v : fallback);

                const display = cfg.display || {};
                autoRotateCheckbox.checked = !!display.autoRotate;
                controls.autoRotate = autoRotateCheckbox.checked;

                axesCheckbox.checked = !!display.showAxes;
                axes.visible = axesCheckbox.checked;

                surfaceToggle.checked = display.showSurface !== false;
                if (mesh) mesh.visible = surfaceToggle.checked;

                wireToggle.checked = !!display.showWireframe;
                if (wireframe) wireframe.visible = wireToggle.checked;

                const dirVal = toNum(display.dirIntensity, 1);
                dirIntensity.value = String(dirVal);
                dirLight.intensity = dirVal;

                const shininessVal = toNum(display.shininess, 100);
                shininessInput.value = String(shininessVal);
                if (mesh && !Array.isArray(mesh.material) && 'shininess' in mesh.material) {
                    mesh.material.shininess = shininessVal;
                } else if (mesh && Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => { if (m && 'shininess' in m) m.shininess = shininessVal; });
                }

                if (display.camera) {
                    const pos = display.camera.position;
                    const tgt = display.camera.target;
                    if (pos && typeof pos.x === 'number') {
                        camera.position.set(pos.x, pos.y, pos.z);
                    } else {
                        // Default if missing
                        camera.position.copy(initialCameraPosition);
                    }
                    if (tgt && typeof tgt.x === 'number') {
                        controls.target.set(tgt.x, tgt.y, tgt.z);
                    } else {
                        controls.target.copy(initialTarget);
                    }
                    controls.update();
                } else {
                    // Reset to default if no camera info in save
                    camera.position.copy(initialCameraPosition);
                    controls.target.copy(initialTarget);
                    controls.update();
                }

                const parameters = cfg.parameters || {};
                params.uMin = toNum(parameters.uMin, 0);
                params.uMax = toNum(parameters.uMax, 1);
                params.vMin = toNum(parameters.vMin, 0);
                params.vMax = toNum(parameters.vMax, 1);
                params.uSegs = Math.max(10, Math.min(500, toNum(parameters.uSegs, 150)));
                params.vSegs = Math.max(3, Math.min(500, toNum(parameters.vSegs, 150)));

                document.getElementById('uMin').value = String(params.uMin);
                document.getElementById('uMax').value = String(params.uMax);
                document.getElementById('vMin').value = String(params.vMin);
                document.getElementById('vMax').value = String(params.vMax);
                document.getElementById('uSegs').value = String(params.uSegs);
                document.getElementById('vSegs').value = String(params.vSegs);

                const extras = Array.isArray(cfg.extraParameters) ? cfg.extraParameters : [];
                const extrasContainer = document.getElementById('paramExtras');
                if (extrasContainer) {
                    animatedParams.splice(0, animatedParams.length);
                    while (extrasContainer.firstChild) {
                        extrasContainer.removeChild(extrasContainer.firstChild);
                    }
                }

                extras.forEach((item) => {
                    if (!item || typeof item !== 'object') return;
                    addParameterRow();
                    const state = animatedParams[animatedParams.length - 1];
                    if (!state) return;

                    const name = typeof item.name === 'string' ? item.name : '';
                    state.nameInput.value = name;
                    state.nameInput.dataset.prevName = name;

                    const val = toNum(item.value, 1);
                    const minVal = toNum(item.min, val - 1);
                    const maxVal = toNum(item.max, val + 1);
                    const stepVal = toNum(item.step, 0.001);
                    const runtimeVal = toNum(item.runtime, 8);

                    state.valueInput.value = formatScalar(val);
                    state.minInput.value = formatScalar(minVal);
                    state.maxInput.value = formatScalar(maxVal);
                    state.stepInput.value = formatScalar(stepVal);
                    state.timeInput.value = formatScalar(runtimeVal);

                    state.sliderInput.min = String(minVal);
                    state.sliderInput.max = String(maxVal);
                    state.sliderInput.value = String(val);
                    state.sliderInput.step = String(stepVal);
                });

                const outputs = cfg.outputs || {};
                const coordMode = outputs.coordConversion === 'spherical' || outputs.coordConversion === 'cylindrical' ? outputs.coordConversion : 'none';
                coordConversionMode = coordMode;
                const coordSelect = document.getElementById('coordConversion');
                if (coordSelect) coordSelect.value = coordMode;

                convertRgbToHsv = !!outputs.rgbToHsv;
                const rgbToHsvCheckbox = document.getElementById('rgbToHsv');
                if (rgbToHsvCheckbox) rgbToHsvCheckbox.checked = convertRgbToHsv;

                const surfaceCfg = cfg.surface || {};
                const code = typeof surfaceCfg.code === 'string' && surfaceCfg.code.trim().length ? surfaceCfg.code : surface.toString();
                editor.setValue(code);
                editor.refresh();
                lastAppliedCode = code;
                try {
                    const factory = new Function(code + '; return surface;');
                    const fn = factory();
                    if (typeof fn === 'function') {
                        surfaceFn = fn;
                        try {
                            const testInput = { u: 0.5, v: 0.5 };
                            fn(testInput);
                        } catch (innerErr) {
                            console.warn('Surface function test failed:', innerErr);
                        }
                    } else {
                        surfaceFn = surface;
                    }
                } catch (err) {
                    console.error('Failed to compile surface function:', err);
                    surfaceFn = surface;
                }

                setSurfaceError('');
                updateSurfaceButtonsState();
                scheduleGeometryUpdate();
                updateGlobalControlsVisibility();
            }

            function collectCurrentConfig() {
                const display = {
                    autoRotate: !!autoRotateCheckbox.checked,
                    showAxes: !!axesCheckbox.checked,
                    showSurface: !!surfaceToggle.checked,
                    showWireframe: !!wireToggle.checked,
                    dirIntensity: parseFloat(dirIntensity.value) || 0,
                    shininess: getCurrentShininess(),
                    camera: {
                        position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                        target: { x: controls.target.x, y: controls.target.y, z: controls.target.z }
                    }
                };

                const parameters = {
                    uMin: params.uMin,
                    uMax: params.uMax,
                    vMin: params.vMin,
                    vMax: params.vMax,
                    uSegs: params.uSegs,
                    vSegs: params.vSegs
                };

                const extraParameters = [];
                animatedParams.forEach((state) => {
                    const name = state.nameInput.value.trim();
                    if (!name) return;
                    const parse = (input) => {
                        const raw = input.value;
                        if (!raw || !raw.length) return null;
                        const n = parseFloat(raw);
                        return Number.isNaN(n) ? null : n;
                    };
                    extraParameters.push({
                        name,
                        value: parse(state.valueInput),
                        min: parse(state.minInput),
                        max: parse(state.maxInput),
                        step: parse(state.stepInput),
                        runtime: parse(state.timeInput)
                    });
                });

                const surfaceConfig = {
                    code: editor.getValue()
                };

                const outputs = {
                    coordConversion: coordConversionMode,
                    rgbToHsv: !!convertRgbToHsv
                };

                return {
                    version: 1,
                    display,
                    parameters,
                    extraParameters,
                    surface: surfaceConfig,
                    outputs
                };
            }

            function downloadCurrentConfig() {
                if (!saveNameInput || !downloadSaveBtn) return;
                const rawName = saveNameInput.value.trim();
                if (!rawName) {
                    alert('Please enter a name for the save.');
                    saveNameInput.focus();
                    return;
                }

                const config = collectCurrentConfig();
                const json = JSON.stringify(config, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                let filename = rawName;
                if (!filename.toLowerCase().endsWith('.json')) {
                    filename += '.json';
                }
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                hideHeaderPanels();
            }

            if (downloadSaveBtn) {
                downloadSaveBtn.addEventListener('click', downloadCurrentConfig);
            }

            if (uploadSaveInput) {
                uploadSaveInput.addEventListener('change', () => {
                    const file = uploadSaveInput.files && uploadSaveInput.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const text = String(e.target.result || '');
                            const data = JSON.parse(text);
                            applyConfig(data);
                            hideHeaderPanels();
                        } catch (err) {
                            console.error(err);
                            alert('Failed to load save file.');
                        } finally {
                            uploadSaveInput.value = '';
                        }
                    };
                    reader.readAsText(file);
                });
            }

            const resetButton = document.getElementById('resetCamera');
            resetButton.addEventListener('click', () => {
                camera.position.copy(initialCameraPosition);
                controls.target.copy(initialTarget);
                controls.update();
                resizeRendererToViewport();
            });

            const sidebarWrapper = document.getElementById('sidebar-wrapper');
            const sidebar = document.getElementById('sidebar');
            const toggle = document.getElementById('toggleSidebar');
            let lastSidebarWidth = sidebar.getBoundingClientRect().width;

            toggle.addEventListener('click', () => {
                const willCollapse = !sidebarWrapper.classList.contains('collapsed');

                if (willCollapse) {
                    // Cache current width, then let CSS collapse to minimal
                    lastSidebarWidth = sidebar.getBoundingClientRect().width;
                    sidebarWrapper.classList.add('collapsed');
                    toggle.textContent = '¬ª';
                    sidebar.style.width = '';
                } else {
                    // Restore previous width when expanding
                    sidebarWrapper.classList.remove('collapsed');
                    toggle.textContent = '¬´';
                    if (lastSidebarWidth && Number.isFinite(lastSidebarWidth)) {
                        sidebar.style.width = lastSidebarWidth + 'px';
                    }
                }

                resizeRendererToViewport();
            });

            const resizer = document.getElementById('sidebar-resizer');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;
            const minWidth = 200;
            let maxWidth = Infinity;

            resizer.addEventListener('mousedown', (e) => {
                if (sidebar.classList.contains('collapsed')) return;
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.getBoundingClientRect().width;
                const totalWidth = document.body.clientWidth || window.innerWidth;
                maxWidth = Math.max(minWidth, totalWidth - 40);
                document.body.classList.add('resizing-sidebar');
                e.preventDefault();
            });

            window.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const dx = e.clientX - startX;
                let newWidth = startWidth + dx;
                if (newWidth < minWidth) newWidth = minWidth;
                if (newWidth > maxWidth) newWidth = maxWidth;
                sidebar.style.width = newWidth + 'px';
                lastSidebarWidth = newWidth;
                resizeRendererToViewport();
            });

            window.addEventListener('mouseup', () => {
                if (!isResizing) return;
                isResizing = false;
                document.body.classList.remove('resizing-sidebar');
            });

            renderer.domElement.addEventListener('dblclick', (event) => {
                const rect = renderer.domElement.getBoundingClientRect();
                const x = (event.clientX - rect.left) / rect.width;
                const y = (event.clientY - rect.top) / rect.height;
                mouse.set(x * 2 - 1, -(y * 2 - 1));

                raycaster.setFromCamera(mouse, camera);
                if (!mesh) return;
                const intersects = raycaster.intersectObject(mesh, true);
                if (!intersects.length) return;

                const point = intersects[0].point.clone();

                // Show marker at click point
                clickMarker.position.copy(point);
                clickMarker.scale.set(1, 1, 1);
                clickMarker.visible = true;
                clickMarkerMat.opacity = 1.0;
                markerStartTime = performance.now();

                // Setup camera tween
                const offset = camera.position.clone().sub(controls.target);
                camStartPos.copy(camera.position);
                camStartTarget.copy(controls.target);
                camEndTarget.copy(point);
                camEndPos.copy(point.clone().add(offset));
                camTweenStart = performance.now();
                isCameraTweening = true;
            });

            // Load nautilus by default on startup
            fetch('saves/nautilus.json')
                .then((res) => {
                    if (!res.ok) throw new Error('Failed to load default surface');
                    return res.json();
                })
                .then((cfg) => {
                    applyConfig(cfg);
                })
                .catch((err) => {
                    console.error('Failed to load default surface:', err);
                    updateGeometry();
                });
        }

        setupUI();
        animate();
    </script>
</body>
</html>

