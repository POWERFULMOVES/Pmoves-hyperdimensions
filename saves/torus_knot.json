{
  "version": 1,
  "display": {
    "autoRotate": true,
    "showAxes": false,
    "showSurface": true,
    "showWireframe": false,
    "dirIntensity": 1.2,
    "shininess": 150,
    "camera": {
      "position": {
        "x": 6,
        "y": 6,
        "z": 4
      },
      "target": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    }
  },
  "parameters": {
    "uMin": 0,
    "uMax": 6.28318530718,
    "vMin": 0,
    "vMax": 6.28318530718,
    "uSegs": 200,
    "vSegs": 30
  },
  "extraParameters": [
    {
      "name": "p",
      "value": 3,
      "min": 1,
      "max": 12,
      "step": 1
    },
    {
      "name": "q",
      "value": 7,
      "min": 1,
      "max": 12,
      "step": 1
    },
    {
      "name": "majorRadius",
      "value": 2,
      "min": 0.5,
      "max": 4,
      "step": 0.001
    },
    {
      "name": "minorRadius",
      "value": 0.8,
      "min": 0.1,
      "max": 2,
      "step": 0.001
    },
    {
      "name": "tubeRadius",
      "value": 0.25,
      "min": 0.05,
      "max": 1,
      "step": 0.001
    },
    {
      "name": "twist",
      "value": 0,
      "min": 0,
      "max": 6.283,
      "step": 0.001,
      "runtime": 11
    },
    {
      "name": "colorShift",
      "value": 0,
      "min": 0,
      "max": 6.283,
      "step": 0.001,
      "runtime": 17
    },
    {
      "name": "colorFreq",
      "value": 1,
      "min": 0.1,
      "max": 5,
      "step": 0.001,
      "runtime": 23
    }
  ],
  "surface": {
    "code": "function surface(input) {\n    const u = input.u;\n    const v = input.v;\n    const p = Math.round(input.p) || 3;\n    const q = Math.round(input.q) || 7;\n    const R = input.majorRadius || 2;\n    const r = input.minorRadius || 0.8;\n    const tube = input.tubeRadius || 0.25;\n    const twist = input.twist || 0;\n    const colorShift = input.colorShift || 0;\n    const colorFreq = input.colorFreq || 1;\n\n    // Torus knot curve: winds p times around and q times through the torus\n    const phi = u * p;\n    const theta = u * q;\n    \n    // Point on the torus knot curve\n    const kx = (R + r * Math.cos(theta)) * Math.cos(phi);\n    const ky = (R + r * Math.cos(theta)) * Math.sin(phi);\n    const kz = r * Math.sin(theta);\n    \n    // Tangent vector (derivative)\n    const tx = -p * (R + r * Math.cos(theta)) * Math.sin(phi) - q * r * Math.sin(theta) * Math.cos(phi);\n    const ty = p * (R + r * Math.cos(theta)) * Math.cos(phi) - q * r * Math.sin(theta) * Math.sin(phi);\n    const tz = q * r * Math.cos(theta);\n    const tLen = Math.sqrt(tx*tx + ty*ty + tz*tz);\n    const T = {x: tx/tLen, y: ty/tLen, z: tz/tLen};\n    \n    // Approximate normal using the torus center direction\n    const cx = R * Math.cos(phi);\n    const cy = R * Math.sin(phi);\n    const cz = 0;\n    let nx = kx - cx;\n    let ny = ky - cy;\n    let nz = kz - cz;\n    const nLen = Math.sqrt(nx*nx + ny*ny + nz*nz);\n    const N = {x: nx/nLen, y: ny/nLen, z: nz/nLen};\n    \n    // Binormal = T cross N\n    const B = {\n        x: T.y * N.z - T.z * N.y,\n        y: T.z * N.x - T.x * N.z,\n        z: T.x * N.y - T.y * N.x\n    };\n    \n    // Build tube around the curve with optional twist\n    const angle = v + twist * u;\n    const x = kx + tube * (Math.cos(angle) * N.x + Math.sin(angle) * B.x);\n    const y = ky + tube * (Math.cos(angle) * N.y + Math.sin(angle) * B.y);\n    const z = kz + tube * (Math.cos(angle) * N.z + Math.sin(angle) * B.z);\n    \n    // Coloring based on position along knot and around tube\n    const hue = (u * colorFreq / 6.283 + colorShift / 6.283) % 1.0;\n    const sat = 0.7 + 0.3 * Math.sin(v * 2);\n    const lum = 0.45 + 0.15 * Math.cos(v);\n    \n    // HSL to RGB\n    const c = (1 - Math.abs(2 * lum - 1)) * sat;\n    const hp = hue * 6;\n    const x_c = c * (1 - Math.abs((hp % 2) - 1));\n    const m = lum - c / 2;\n    let r_out, g_out, b_out;\n    if (hp < 1) { r_out = c; g_out = x_c; b_out = 0; }\n    else if (hp < 2) { r_out = x_c; g_out = c; b_out = 0; }\n    else if (hp < 3) { r_out = 0; g_out = c; b_out = x_c; }\n    else if (hp < 4) { r_out = 0; g_out = x_c; b_out = c; }\n    else if (hp < 5) { r_out = x_c; g_out = 0; b_out = c; }\n    else { r_out = c; g_out = 0; b_out = x_c; }\n\n    return {\n        x, y, z,\n        r: r_out + m,\n        g: g_out + m,\n        b: b_out + m,\n        a: 1\n    };\n}"
  },
  "outputs": {
    "coordConversion": "none",
    "rgbToHsv": false
  }
}