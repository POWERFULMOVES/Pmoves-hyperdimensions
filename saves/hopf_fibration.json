{
  "version": 1,
  "display": {
    "autoRotate": false,
    "showAxes": false,
    "showSurface": true,
    "showWireframe": false,
    "dirIntensity": 1.2,
    "shininess": 200,
    "camera": {
      "position": {
        "x": 6,
        "y": 6,
        "z": 5
      },
      "target": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    }
  },
  "parameters": {
    "uMin": 0,
    "uMax": 6.28318530718,
    "vMin": 0,
    "vMax": 3.14159265359,
    "uSegs": 150,
    "vSegs": 80
  },
  "extraParameters": [
    {
      "name": "fiberRadius",
      "value": 0.08,
      "min": 0.02,
      "max": 0.5,
      "step": 0.001
    },
    {
      "name": "projectionDist",
      "value": 2,
      "min": 1,
      "max": 4,
      "step": 0.001
    },
    {
      "name": "rotation4D",
      "value": 0,
      "min": 0,
      "max": 6.283,
      "step": 0.001,
      "runtime": 17
    },
    {
      "name": "twist4D",
      "value": 0,
      "min": 0,
      "max": 6.283,
      "step": 0.001,
      "runtime": 23
    },
    {
      "name": "baseRotation",
      "value": 0,
      "min": 0,
      "max": 6.283,
      "step": 0.001,
      "runtime": 11
    },
    {
      "name": "colorSpeed",
      "value": 0,
      "min": 0,
      "max": 6.283,
      "step": 0.001,
      "runtime": 29
    },
    {
      "name": "saturation",
      "value": 0.9,
      "min": 0,
      "max": 1,
      "step": 0.001,
      "runtime": 41
    }
  ],
  "surface": {
    "code": "function surface(input) {\n    const u = input.u;  // Position along fiber (circle)\n    const v = input.v;  // Which fiber (colatitude on base S2)\n    const fiberR = input.fiberRadius || 0.08;\n    const projDist = input.projectionDist || 2;\n    const rot4D = input.rotation4D || 0;\n    const twist4D = input.twist4D || 0;\n    const baseRot = input.baseRotation || 0;\n    const colorSpeed = input.colorSpeed || 0;\n    const sat = input.saturation || 0.9;\n\n    // Hopf fibration: S3 -> S2\n    // Each point on S2 (base) corresponds to a circle (fiber) in S3\n    \n    // Base sphere coordinates (which fiber we're on)\n    const theta = v;  // colatitude [0, PI]\n    const phi = u * 0.5 + baseRot;  // longitude, scaled to show multiple fibers\n    \n    // Fiber parameter (position along the circle)\n    const psi = u + twist4D * Math.sin(v * 2);\n    \n    // Hopf map: (theta, phi, psi) -> point on S3\n    // Using the standard Hopf coordinates\n    const cosHalf = Math.cos(theta / 2);\n    const sinHalf = Math.sin(theta / 2);\n    \n    let x1 = cosHalf * Math.cos(psi + phi / 2);\n    let x2 = cosHalf * Math.sin(psi + phi / 2);\n    let x3 = sinHalf * Math.cos(psi - phi / 2);\n    let x4 = sinHalf * Math.sin(psi - phi / 2);\n    \n    // 4D rotation in the x1-x4 plane\n    const c4 = Math.cos(rot4D);\n    const s4 = Math.sin(rot4D);\n    const x1r = x1 * c4 - x4 * s4;\n    const x4r = x1 * s4 + x4 * c4;\n    x1 = x1r;\n    x4 = x4r;\n    \n    // Additional rotation in x2-x3 plane\n    const c42 = Math.cos(rot4D * 0.7);\n    const s42 = Math.sin(rot4D * 0.7);\n    const x2r = x2 * c42 - x3 * s42;\n    const x3r = x2 * s42 + x3 * c42;\n    x2 = x2r;\n    x3 = x3r;\n    \n    // Stereographic projection from S3 to R3\n    const w = x4;\n    const denom = projDist - w;\n    const safeDenom = Math.abs(denom) < 0.01 ? 0.01 * Math.sign(denom || 1) : denom;\n    const factor = projDist / safeDenom;\n    \n    // Add thickness to make fibers visible as tubes\n    const fiberAngle = u * 8; // tube cross-section\n    const thick = fiberR * (1 + 0.3 * (factor - 1) / 2); // scale with projection\n    \n    // Approximate normal to fiber for tube\n    const nx = Math.sin(v) * Math.cos(u);\n    const ny = Math.sin(v) * Math.sin(u);\n    const nz = Math.cos(v);\n    \n    const x = x1 * factor + thick * nx * Math.cos(fiberAngle);\n    const y = x2 * factor + thick * ny * Math.cos(fiberAngle);\n    const z = x3 * factor + thick * nz * Math.sin(fiberAngle);\n    \n    // Color by fiber (base sphere position) - creates linked rainbow rings\n    const hue = (v / 3.14159 + colorSpeed / 6.283) % 1.0;\n    const lum = 0.4 + 0.2 * Math.sin(u * 4);\n    \n    // HSL to RGB\n    const c = (1 - Math.abs(2 * lum - 1)) * sat;\n    const hp = hue * 6;\n    const x_c = c * (1 - Math.abs((hp % 2) - 1));\n    const m = lum - c / 2;\n    let r_out, g_out, b_out;\n    if (hp < 1) { r_out = c; g_out = x_c; b_out = 0; }\n    else if (hp < 2) { r_out = x_c; g_out = c; b_out = 0; }\n    else if (hp < 3) { r_out = 0; g_out = c; b_out = x_c; }\n    else if (hp < 4) { r_out = 0; g_out = x_c; b_out = c; }\n    else if (hp < 5) { r_out = x_c; g_out = 0; b_out = c; }\n    else { r_out = c; g_out = 0; b_out = x_c; }\n\n    return {\n        x, y, z,\n        r: r_out + m,\n        g: g_out + m,\n        b: b_out + m,\n        a: 1\n    };\n}"
  },
  "outputs": {
    "coordConversion": "none",
    "rgbToHsv": false
  }
}