{
  "version": 1,
  "display": {
    "autoRotate": false,
    "showAxes": false,
    "showSurface": true,
    "showWireframe": true,
    "dirIntensity": 0.8,
    "shininess": 60,
    "camera": {
      "position": {
        "x": 8.292337121619003,
        "y": -13.382339404732717,
        "z": 8.603635736803405
      },
      "target": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    }
  },
  "parameters": {
    "uMin": 0,
    "uMax": 6.283185,
    "vMin": 0,
    "vMax": 6.283185,
    "uSegs": 100,
    "vSegs": 50
  },
  "extraParameters": [
    {
      "name": "handleWidth",
      "value": 1,
      "min": 0.5,
      "max": 2.5,
      "step": 0.001,
      "runtime": 8
    },
    {
      "name": "bodyWidth",
      "value": 1,
      "min": 0.5,
      "max": 2,
      "step": 0.001,
      "runtime": 8
    }
  ],
  "surface": {
    "code": "function surface(input) {\n    const u = input.u;\n    const v = input.v;\n    const handleW = input.handleWidth || 1.0;\n    const bodyW = input.bodyWidth || 1.0;\n\n    const cosU = Math.cos(u);\n    const sinU = Math.sin(u);\n    const cosV = Math.cos(v);\n    const sinV = Math.sin(v);\n    \n    let x, y, z;\n\n    // Adjusted Classic Klein Bottle Parameterization\n    if (u < Math.PI) {\n        // Bottom body\n        x = (6 * bodyW) * cosU * (1 + sinU) + (4 * handleW) * (1 - cosU / 2) * cosU * cosV;\n        y = 16 * sinU + (4 * handleW) * (1 - cosU / 2) * sinU * cosV;\n        z = (4 * handleW) * (1 - cosU / 2) * sinV;\n    } else {\n        // Handle / Neck\n        x = (6 * bodyW) * cosU * (1 + sinU) - (4 * handleW) * (1 - cosU / 2) * cosV;\n        y = 16 * sinU;\n        z = (4 * handleW) * (1 - cosU / 2) * sinV;\n    }\n    \n    // Scale down to fit view\n    const s = 0.25;\n    x *= s;\n    y *= s;\n    z *= s;\n    \n    // Center vertically\n    y -= 2;\n\n    // Coloring logic corrected for U-seam (0 to 2PI)\n    // We use sin(u) instead of u directly to ensure periodicity\n    \n    // Base hue on Y height + a twist based on U angle\n    // Using sin(u) ensures that u=0 and u=2PI result in the same color value\n    const phase = y * 0.3 + Math.sin(u) * 2.0;\n    \n    const r_col = 0.5 + 0.5 * Math.sin(phase);\n    const g_col = 0.5 + 0.5 * Math.sin(phase + 2.09); // + 120 degrees\n    const b_col = 0.5 + 0.5 * Math.sin(phase + 4.18); // + 240 degrees\n\n    // Light shading based on V (tube circumference)\n    const shading = 0.9 + 0.1 * cosV;\n\n    return { \n        x, y, z, \n        r: r_col * shading, \n        g: g_col * shading, \n        b: b_col * shading, \n        a: 1.0 \n    };\n}"
  },
  "outputs": {
    "coordConversion": "none",
    "rgbToHsv": false
  }
}