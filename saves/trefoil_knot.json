{
  "version": 1,
  "display": {
    "autoRotate": true,
    "showAxes": false,
    "showSurface": true,
    "showWireframe": false,
    "dirIntensity": 1.3,
    "shininess": 180,
    "camera": {
      "position": {
        "x": 5,
        "y": 5,
        "z": 4
      },
      "target": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    }
  },
  "parameters": {
    "uMin": 0,
    "uMax": 6.28318530718,
    "vMin": 0,
    "vMax": 6.28318530718,
    "uSegs": 180,
    "vSegs": 24
  },
  "extraParameters": [
    {
      "name": "scale",
      "value": 1.5,
      "min": 0.5,
      "max": 3,
      "step": 0.001
    },
    {
      "name": "tubeRadius",
      "value": 0.4,
      "min": 0.1,
      "max": 1.5,
      "step": 0.001
    },
    {
      "name": "phase",
      "value": 0,
      "min": 0,
      "max": 6.283,
      "step": 0.001,
      "runtime": 13
    },
    {
      "name": "wobble",
      "value": 0,
      "min": 0,
      "max": 0.5,
      "step": 0.001,
      "runtime": 9
    },
    {
      "name": "hueOffset",
      "value": 0,
      "min": 0,
      "max": 1,
      "step": 0.001,
      "runtime": 19
    },
    {
      "name": "saturation",
      "value": 0.8,
      "min": 0,
      "max": 1,
      "step": 0.001,
      "runtime": 29
    },
    {
      "name": "iridescence",
      "value": 0.5,
      "min": 0,
      "max": 2,
      "step": 0.001,
      "runtime": 37
    }
  ],
  "surface": {
    "code": "function surface(input) {\n    const u = input.u;\n    const v = input.v;\n    const scale = input.scale || 1.5;\n    const tube = input.tubeRadius || 0.4;\n    const phase = input.phase || 0;\n    const wobble = input.wobble || 0;\n    const hueOffset = input.hueOffset || 0;\n    const sat = input.saturation || 0.8;\n    const irid = input.iridescence || 0.5;\n\n    // Classic trefoil knot parametrization\n    const t = u + phase;\n    const kx = scale * (Math.sin(t) + 2 * Math.sin(2 * t));\n    const ky = scale * (Math.cos(t) - 2 * Math.cos(2 * t));\n    const kz = scale * (-Math.sin(3 * t));\n    \n    // Add wobble\n    const wobbleAmt = wobble * Math.sin(5 * t + phase * 3);\n    \n    // Tangent vector\n    const tx = scale * (Math.cos(t) + 4 * Math.cos(2 * t));\n    const ty = scale * (-Math.sin(t) + 4 * Math.sin(2 * t));\n    const tz = scale * (-3 * Math.cos(3 * t));\n    const tLen = Math.sqrt(tx*tx + ty*ty + tz*tz);\n    const T = {x: tx/tLen, y: ty/tLen, z: tz/tLen};\n    \n    // Second derivative for normal calculation\n    const ddx = scale * (-Math.sin(t) - 8 * Math.sin(2 * t));\n    const ddy = scale * (-Math.cos(t) + 8 * Math.cos(2 * t));\n    const ddz = scale * (9 * Math.sin(3 * t));\n    \n    // Normal from second derivative component perpendicular to tangent\n    const dot = (ddx * T.x + ddy * T.y + ddz * T.z);\n    let nx = ddx - dot * T.x;\n    let ny = ddy - dot * T.y;\n    let nz = ddz - dot * T.z;\n    const nLen = Math.sqrt(nx*nx + ny*ny + nz*nz) + 0.0001;\n    const N = {x: nx/nLen, y: ny/nLen, z: nz/nLen};\n    \n    // Binormal\n    const B = {\n        x: T.y * N.z - T.z * N.y,\n        y: T.z * N.x - T.x * N.z,\n        z: T.x * N.y - T.y * N.x\n    };\n    \n    // Tube around the curve\n    const tubeR = tube + wobbleAmt;\n    const x = kx + tubeR * (Math.cos(v) * N.x + Math.sin(v) * B.x);\n    const y = ky + tubeR * (Math.cos(v) * N.y + Math.sin(v) * B.y);\n    const z = kz + tubeR * (Math.cos(v) * N.z + Math.sin(v) * B.z);\n    \n    // Iridescent coloring - shifts with viewing angle (approximated by v)\n    const hue = (u / 6.283 + hueOffset + irid * Math.sin(v * 2 + u * 3)) % 1.0;\n    const lum = 0.4 + 0.2 * Math.cos(v);\n    \n    // HSL to RGB\n    const c = (1 - Math.abs(2 * lum - 1)) * sat;\n    const hp = hue * 6;\n    const x_c = c * (1 - Math.abs((hp % 2) - 1));\n    const m = lum - c / 2;\n    let r_out, g_out, b_out;\n    if (hp < 1) { r_out = c; g_out = x_c; b_out = 0; }\n    else if (hp < 2) { r_out = x_c; g_out = c; b_out = 0; }\n    else if (hp < 3) { r_out = 0; g_out = c; b_out = x_c; }\n    else if (hp < 4) { r_out = 0; g_out = x_c; b_out = c; }\n    else if (hp < 5) { r_out = x_c; g_out = 0; b_out = c; }\n    else { r_out = c; g_out = 0; b_out = x_c; }\n\n    return {\n        x, y, z,\n        r: r_out + m,\n        g: g_out + m,\n        b: b_out + m,\n        a: 1\n    };\n}"
  },
  "outputs": {
    "coordConversion": "none",
    "rgbToHsv": false
  }
}