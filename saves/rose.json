{
  "version": 1,
  "display": {
    "autoRotate": true,
    "showAxes": false,
    "showSurface": true,
    "showWireframe": false,
    "dirIntensity": 1.5,
    "shininess": 100,
    "camera": {
      "position": {
        "x": 3,
        "y": 3,
        "z": 4
      },
      "target": {
        "x": 0,
        "y": 0,
        "z": 0.5
      }
    }
  },
  "parameters": {
    "uMin": 0,
    "uMax": 1,
    "vMin": -6.28318,
    "vMax": 47.1239,
    "uSegs": 50,
    "vSegs": 300
  },
  "extraParameters": [
    {
      "name": "bloom",
      "value": 1,
      "min": 0,
      "max": 1,
      "step": 0.001,
      "runtime": 15
    },
    {
      "name": "petalCurl",
      "value": 8,
      "min": 4,
      "max": 16,
      "step": 0.001
    },
    {
      "name": "petalShape",
      "value": 3.6,
      "min": 2,
      "max": 6,
      "step": 0.001,
      "runtime": 37
    },
    {
      "name": "height",
      "value": 1,
      "min": 0.5,
      "max": 2,
      "step": 0.001
    },
    {
      "name": "spread",
      "value": 1,
      "min": 0.5,
      "max": 2,
      "step": 0.001,
      "runtime": 23
    },
    {
      "name": "innerHue",
      "value": 0.95,
      "min": 0,
      "max": 1,
      "step": 0.001,
      "runtime": 53
    },
    {
      "name": "outerHue",
      "value": 0.0,
      "min": 0,
      "max": 1,
      "step": 0.001,
      "runtime": 67
    },
    {
      "name": "saturation",
      "value": 0.85,
      "min": 0,
      "max": 1,
      "step": 0.001,
      "runtime": 83
    },
    {
      "name": "brightness",
      "value": 0.6,
      "min": 0.2,
      "max": 1,
      "step": 0.001,
      "runtime": 97
    }
  ],
  "surface": {
    "code": "function surface(input) {\n    const x = input.u;      // 0 to 1: position along petal (base to tip)\n    const theta = input.v;  // -2π to 15π: spiral angle\n    \n    const bloomAmt = input.bloom || 1;\n    const curlSpeed = input.petalCurl || 8;\n    const petalMod = input.petalShape || 3.6;\n    const heightScale = input.height || 1;\n    const spreadScale = input.spread || 1;\n    const hueIn = input.innerHue || 0.95;\n    const hueOut = input.outerHue || 0.0;\n    const sat = input.saturation || 0.85;\n    const bright = input.brightness || 0.6;\n\n    // Adapted from the Mathematica rose equation\n    // phi controls the spiral curl of petals - outer petals lay flatter\n    // Bloom affects how quickly petals unfurl\n    const bloomFactor = 0.3 + bloomAmt * 0.7;  // 0.3 to 1.0\n    const phi = (Math.PI / 2) * Math.exp(-theta / (curlSpeed * Math.PI * bloomFactor));\n    \n    // X creates the petal shape using modulo - gives the rose its layered look\n    const thetaMod = ((theta * petalMod) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);\n    const petalT = 1 - thetaMod / Math.PI;\n    const innerTerm = (5/4) * petalT * petalT - 1/4;\n    const X = 1 - 0.5 * innerTerm * innerTerm;\n    \n    // y is the curved petal profile\n    const y = 1.95653 * x * x * Math.pow(1.27689 * x - 1, 2) * Math.sin(phi);\n    \n    // r is radial distance\n    const r = X * (x * Math.sin(phi) + y * Math.cos(phi)) * spreadScale;\n    \n    // z height\n    const zRaw = X * (x * Math.cos(phi) - y * Math.sin(phi)) * heightScale;\n    \n    // Apply bloom to height - closed rose is taller/tighter\n    const z = zRaw * (0.7 + 0.3 * bloomAmt);\n    \n    // Final 3D coordinates\n    const xOut = r * Math.sin(theta);\n    const yOut = r * Math.cos(theta);\n    const zOut = z;\n\n    // Coloring - gradient from center to outer petals\n    // theta ranges from -2π to 15π, normalize to 0-1\n    const thetaNorm = (theta + 2 * Math.PI) / (17 * Math.PI);\n    const hue = hueIn + (hueOut - hueIn) * thetaNorm;\n    \n    // Variation based on petal position\n    const lumVar = bright * (0.8 + 0.2 * X) * (0.9 + 0.1 * x);\n    const satVar = sat * (0.8 + 0.2 * (1 - x));\n\n    // HSL to RGB\n    const hueNorm = ((hue % 1) + 1) % 1;\n    const lum = lumVar;\n    const c = (1 - Math.abs(2 * lum - 1)) * satVar;\n    const hp = hueNorm * 6;\n    const xc = c * (1 - Math.abs((hp % 2) - 1));\n    const m = lum - c / 2;\n    let rOut, gOut, bOut;\n    if (hp < 1) { rOut = c; gOut = xc; bOut = 0; }\n    else if (hp < 2) { rOut = xc; gOut = c; bOut = 0; }\n    else if (hp < 3) { rOut = 0; gOut = c; bOut = xc; }\n    else if (hp < 4) { rOut = 0; gOut = xc; bOut = c; }\n    else if (hp < 5) { rOut = xc; gOut = 0; bOut = c; }\n    else { rOut = c; gOut = 0; bOut = xc; }\n\n    return {\n        x: xOut,\n        y: yOut,\n        z: zOut,\n        r: rOut + m,\n        g: gOut + m,\n        b: bOut + m,\n        a: 1\n    };\n}"
  },
  "outputs": {
    "coordConversion": "none",
    "rgbToHsv": false
  }
}