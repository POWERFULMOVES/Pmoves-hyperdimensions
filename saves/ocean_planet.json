{
  "version": 1,
  "display": {
    "autoRotate": true,
    "showAxes": false,
    "showSurface": true,
    "showWireframe": false,
    "dirIntensity": 1.4,
    "shininess": 1000,
    "camera": {
      "position": {
        "x": 1.7931087748240495,
        "y": -17.050155323810888,
        "z": 3.4327310525785606
      },
      "target": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    }
  },
  "parameters": {
    "uMin": 0,
    "uMax": 3.14159265359,
    "vMin": 0,
    "vMax": 6.28318530718,
    "uSegs": 180,
    "vSegs": 180
  },
  "extraParameters": [
    {
      "name": "time",
      "value": 700.372,
      "min": 0,
      "max": 1000,
      "step": 0.001,
      "runtime": 500
    },
    {
      "name": "waveHeight",
      "value": 0.116,
      "min": -0.5,
      "max": 0.5,
      "step": 0.001,
      "runtime": 8
    },
    {
      "name": "waveScale",
      "value": 1.816,
      "min": 1,
      "max": 10,
      "step": 0.001,
      "runtime": 8
    },
    {
      "name": "choppiness",
      "value": 0.716,
      "min": 0.3,
      "max": 3,
      "step": 0.001,
      "runtime": 8
    },
    {
      "name": "swirl",
      "value": 1.359,
      "min": 0,
      "max": 2,
      "step": 0.001,
      "runtime": 67
    },
    {
      "name": "deepColor",
      "value": 0.691,
      "min": 0,
      "max": 1,
      "step": 0.001,
      "runtime": 97
    }
  ],
  "surface": {
    "code": "function surface(input) {\n    const u = input.u;\n    const v = input.v;\n    const t = input.time || 0;\n    const amp = input.waveHeight || 0.12;\n    const scale = input.waveScale || 3;\n    const chop = input.choppiness || 1.2;\n    const swirl = input.swirl || 0.3;\n    const deepHue = input.deepColor || 0.58;\n    const R_base = 3.5;\n\n    // Irrational frequency ratios for quasi-periodic (chaotic-looking) waves\n    const phi = 1.618033988749895;\n    const sqrt2 = 1.4142135623730951;\n    const sqrt3 = 1.7320508075688772;\n\n    // Sphere unit normal - using this ensures seamless wrapping\n    let nx = Math.sin(u) * Math.cos(v);\n    let ny = Math.sin(u) * Math.sin(v);\n    let nz = Math.cos(u);\n\n    // Domain warping in 3D - creates swirling currents\n    // All operations use 3D coords so seams are impossible\n    const wx = nx + swirl * Math.sin(ny * phi * 2 + nz * sqrt2 + t * 0.2);\n    const wy = ny + swirl * Math.sin(nz * sqrt3 * 2 + nx * phi + t * 0.17);\n    const wz = nz + swirl * Math.sin(nx * sqrt2 * 2 + ny * sqrt3 + t * 0.23);\n\n    // Trochoidal wave function - sharp peaks, flat troughs (like real ocean)\n    const trochoid = (x, y, z, freq, speed, sharpness) => {\n        const wave = Math.sin(x * freq + t * speed) + \n                     Math.sin(y * freq * phi + t * speed * 0.9) + \n                     Math.sin(z * freq * sqrt2 + t * speed * 1.1);\n        return Math.pow(Math.abs(wave / 3), sharpness) * Math.sign(wave);\n    };\n\n    // Accumulate wave layers with golden ratio frequency scaling\n    let h = 0;\n    \n    // Layer 1: Large ocean swells\n    h += trochoid(wx, wy, wz, scale, 0.5, chop) * 1.0;\n    \n    // Layer 2: Medium waves - rotated coordinates for variety\n    h += trochoid(wy + wx, wz - wy, wx + wz, scale * phi, 0.7, chop * 1.1) * 0.5;\n    \n    // Layer 3: Smaller chop\n    h += trochoid(wx - wz, wy + wx, wz - wy, scale * phi * phi, 1.0, chop * 0.9) * 0.25;\n    \n    // Layer 4: Fine detail / ripples\n    h += trochoid(wz, wx, wy, scale * phi * phi * phi, 1.5, 1.0) * 0.12;\n    \n    // Layer 5: Micro texture\n    const micro = Math.sin((wx * 7 + wy * 11 + wz * 13) * scale + t * 2);\n    h += micro * 0.06;\n\n    // Apply displacement\n    const R = R_base + h * amp;\n    const x = R * nx;\n    const y = R * ny;\n    const z = R * nz;\n\n    // Water coloring\n    // Normalize height for coloring (h ranges roughly -2 to 2)\n    const hNorm = (h + 2) / 4;\n    const heightVal = Math.max(0, Math.min(1, hNorm));\n    \n    // Ocean color palette - all in HSL for smooth blending\n    // Deep: dark blue, Mid: teal/cyan, Shallow: turquoise, Foam: white\n    const deepH = deepHue, deepS = 0.85, deepL = 0.12;\n    const midH = deepHue - 0.05, midS = 0.75, midL = 0.3;\n    const shallowH = deepHue - 0.1, shallowS = 0.6, shallowL = 0.55;\n    const foamH = deepHue - 0.08, foamS = 0.15, foamL = 0.92;\n\n    let hue, sat, lum;\n    if (heightVal < 0.35) {\n        const t_c = heightVal / 0.35;\n        hue = deepH + (midH - deepH) * t_c;\n        sat = deepS + (midS - deepS) * t_c;\n        lum = deepL + (midL - deepL) * t_c;\n    } else if (heightVal < 0.65) {\n        const t_c = (heightVal - 0.35) / 0.3;\n        hue = midH + (shallowH - midH) * t_c;\n        sat = midS + (shallowS - midS) * t_c;\n        lum = midL + (shallowL - midL) * t_c;\n    } else {\n        const t_c = (heightVal - 0.65) / 0.35;\n        const foamPow = Math.pow(t_c, 2.5);  // Sharp foam at peaks\n        hue = shallowH + (foamH - shallowH) * foamPow;\n        sat = shallowS + (foamS - shallowS) * foamPow;\n        lum = shallowL + (foamL - shallowL) * foamPow;\n    }\n\n    // HSL to RGB\n    const c = (1 - Math.abs(2 * lum - 1)) * sat;\n    const hp = (hue % 1) * 6;\n    const xc = c * (1 - Math.abs((hp % 2) - 1));\n    const m = lum - c / 2;\n    let r, g, b;\n    if (hp < 1) { r = c; g = xc; b = 0; }\n    else if (hp < 2) { r = xc; g = c; b = 0; }\n    else if (hp < 3) { r = 0; g = c; b = xc; }\n    else if (hp < 4) { r = 0; g = xc; b = c; }\n    else if (hp < 5) { r = xc; g = 0; b = c; }\n    else { r = c; g = 0; b = xc; }\n\n    return { x, y, z, r: r + m, g: g + m, b: b + m, a: 1 };\n}"
  },
  "outputs": {
    "coordConversion": "none",
    "rgbToHsv": false
  }
}