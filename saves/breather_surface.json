{
  "version": 1,
  "display": {
    "autoRotate": true,
    "showAxes": false,
    "showSurface": true,
    "showWireframe": false,
    "dirIntensity": 1.2,
    "shininess": 150,
    "camera": {
      "position": {
        "x": -5.259819110902405,
        "y": 7.5118001790560776,
        "z": 4.32288070129721
      },
      "target": {
        "x": 0,
        "y": 0,
        "z": 0
      }
    }
  },
  "parameters": {
    "uMin": -13.5,
    "uMax": 13.5,
    "vMin": -37.5,
    "vMax": 37.5,
    "uSegs": 100,
    "vSegs": 200
  },
  "extraParameters": [
    {
      "name": "scale",
      "value": 0.25,
      "min": 0.1,
      "max": 1,
      "step": 0.001,
      "runtime": 8
    },
    {
      "name": "colorPhase",
      "value": 2.707,
      "min": 0,
      "max": 6.283,
      "step": 0.001,
      "runtime": 21
    },
    {
      "name": "hueRange",
      "value": 0.741,
      "min": 0.1,
      "max": 1,
      "step": 0.001,
      "runtime": 31
    },
    {
      "name": "saturation",
      "value": 1,
      "min": 0,
      "max": 1,
      "step": 0.001,
      "runtime": 37
    }
  ],
  "surface": {
    "code": "function surface(input) {\n    const u = input.u;\n    const v = input.v;\n    const b = input.breathe || 0.4;  // Breather parameter (0 < b < 1)\n    const t = input.time || 0;\n    const sc = input.scale || 0.25;\n    const colorPhase = input.colorPhase || 0;\n    const hueRange = input.hueRange || 0.6;\n    const sat = input.saturation || 0.85;\n\n    // Breather surface - a soliton solution to the sine-Gordon equation\n    // This is a genuine parametric minimal-like surface with beautiful structure\n    \n    const aa = 1 - b * b;\n    const r = Math.sqrt(aa);\n    const w = Math.sqrt(b);\n    \n    // Time-dependent phase for animation\n    const phase = t * 0.5;\n    \n    // Breather parametric equations\n    const denom = b * (Math.pow(r * Math.cosh(b * u), 2) + Math.pow(b * Math.sin(r * (v + phase)), 2));\n    \n    const x = sc * (-u + (2 * aa * Math.cosh(b * u) * Math.sinh(b * u)) / denom);\n    const y = sc * (2 * r * Math.cosh(b * u) * (-(r * Math.cos(v + phase) * Math.cos(r * (v + phase))) - Math.sin(v + phase) * Math.sin(r * (v + phase)))) / denom;\n    const z = sc * (2 * r * Math.cosh(b * u) * (-(r * Math.sin(v + phase) * Math.cos(r * (v + phase))) + Math.cos(v + phase) * Math.sin(r * (v + phase)))) / denom;\n    \n    // Coloring based on surface curvature/position\n    const curvature = Math.tanh(b * u); // -1 to 1\n    const vNorm = ((v + phase) % 6.283) / 6.283;\n    \n    const hue = (0.5 + curvature * hueRange * 0.5 + colorPhase / 6.283) % 1.0;\n    const lum = 0.35 + 0.25 * (curvature + 1) / 2 + 0.1 * Math.sin(vNorm * 6.283 * 3);\n    \n    // HSL to RGB\n    const c = (1 - Math.abs(2 * lum - 1)) * sat;\n    const hp = hue * 6;\n    const x_c = c * (1 - Math.abs((hp % 2) - 1));\n    const m = lum - c / 2;\n    let r_out, g_out, b_out;\n    if (hp < 1) { r_out = c; g_out = x_c; b_out = 0; }\n    else if (hp < 2) { r_out = x_c; g_out = c; b_out = 0; }\n    else if (hp < 3) { r_out = 0; g_out = c; b_out = x_c; }\n    else if (hp < 4) { r_out = 0; g_out = x_c; b_out = c; }\n    else if (hp < 5) { r_out = x_c; g_out = 0; b_out = c; }\n    else { r_out = c; g_out = 0; b_out = x_c; }\n\n    return {\n        x, y, z,\n        r: r_out + m,\n        g: g_out + m,\n        b: b_out + m,\n        a: 1\n    };\n}"
  },
  "outputs": {
    "coordConversion": "none",
    "rgbToHsv": false
  }
}